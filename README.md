<h1>이미지</h1>
Docker의 핵심 요소 두 가지 는 이미지 와 컨테이너입니다
이미지는 컨테이너의 청사진 또는 템플릿으로, 읽기 전용이며 애플리케이션과 필요한 애플리케이션 환경(운영 체제, 런타임, 도구 등)을 포함하고 있습니다.
이미지는 스스로 실행되지 않으며, 대신 컨테이너로 실행될 수 있습니다.<br>
이미지는 사전에 빌드되어 있거나(DockerHub에서 찾을 수 있는 공식 이미지 등) Dockerfile을 정의하여 직접 빌드할 수 있습니다.<br>
Dockerfile에는 이미지가 빌드될 때(docker build .) 실행되는 명령이 포함되어 있으며, 각 명령은 이미지 내에 레이어를 생성합니다. <br>
레이어는 이미지를 효율적으로 재빌드하고 공유하는 데 사용됩니다.
CMD 명령은  이미지가 빌드될 때 실행되는 것이 아니라 해당 이미지를 기반으로 컨테이너가 생성되고 시작될 때 실행됩니다.
<br><br>
<h1>컨테이너</h1>
컨테이너는 Docker의 또 다른 핵심 구성 요소입니다.
컨테이너는 이미지의 실행 인스턴스입니다. 컨테이너를 생성할 때(docker run을 통해), 이미지 위에 얇은 읽기-쓰기 레이어가 추가됩니다.
따라서 하나의 이미지를 기반으로 여러 컨테이너를 시작할 수 있습니다. 모든 컨테이너는 격리된 상태로 실행되며, 즉 애플리케이션 상태나 쓰여진 데이터를 공유하지 않습니다.
컨테이너 내부의 애플리케이션을 시작하려면 컨테이너를 생성하고 시작해야 합니다. 결국 실행되는 것은 컨테이너이며, 이는 개발과 생산 모두에서 마찬가지입니다.
<br><br>
<h1>핵심 도커 명령어 </h1>
모든 명령어의 전체 목록을 보려면 명령어 뒤에 --help를 추가하세요. 예: docker --help, docker run --help 등.
공식 문서에서 모든 명령어와 기능에 대한 자세한 설명도 확인할 수 있습니다.<br>

`docker build .`: Dockerfile을 빌드하고 파일을 기반으로 자신만의 이미지를 생성합니다.<br>
`-t NAME:TAG`: 이미지에 이름(NAME)과 태그(TAG)를 할당합니다.<br>
`docker run IMAGE_NAME`: 이미지 IMAGE_NAME을 기반으로 새 컨테이너를 생성하고 시작합니다.<br>
`--name NAME`: 컨테이너에 이름(NAME)을 할당합니다. 이 이름은 컨테이너를 중지하거나 제거할 때 사용할 수 있습니다.<br>
`-d`: 컨테이너를 분리된 모드에서 실행합니다. 즉, 컨테이너가 출력하는 내용은 보이지 않고, 명령 프롬프트/터미널은 컨테이너가 중지될 때까지 기다리지 않습니다.<br>
`-it`: 컨테이너를 "대화형" 모드에서 실행합니다. 이 경우, 컨테이너/애플리케이션은 명령 프롬프트/터미널을 통한 입력을 받을 준비가 됩니다. -it 플래그를 사용할 때는 CTRL + C로 컨테이너를 중지할 수 있습니다.<br>
`--rm`: 컨테이너가 중지되면 자동으로 컨테이너를 제거합니다.<br>
`docker ps`: 실행 중인 모든 컨테이너를 나열합니다.<br>
`-a`: 중지된 컨테이너를 포함하여 모든 컨테이너를 나열합니다.<br>
`docker images`: 로컬에 저장된 모든 이미지를 나열합니다.<br>
`docker rm CONTAINER`: 이름(CONTAINER)을 가진 컨테이너를 제거합니다(컨테이너 ID를 사용할 수도 있습니다).<br>
`docker rmi IMAGE`: 이름/ID로 이미지를 제거합니다.<br>
`docker container prune`: 모든 중지된 컨테이너를 제거합니다.<br>
`docker image prune`: 모든  이미지(태그가 없는 이미지)를 제거합니다.<br>
`docker push IMAGE`: 이미지를 DockerHub(또는 다른 레지스트리)에 푸시합니다. 이미지 이름/태그는 저장소 이름/URL을 포함해야 합니다.<br>
`docker pull IMAGE`: 이미지를 DockerHub(또는 다른 레지스트리)에서 가져옵니다. 이미지가 이전에 가져오지 않은 경우 docker run IMAGE만 실행하면 자동으로 이루어집니다.<br>




<h1> 이미 실행 중인 컨테이너에 연결하기</h1>

디폴트로 '-d' 없이 컨테이너를 실행하면, "attached모드"로 실행됩니다.

detached 모드(예: -d)로 컨테이너를 시작한 경우에는 다음 명령을 사용하여 컨테이너를 다시 시작하지 않고도 컨테이너에 연결할 수 있습니다.

docker attach CONTAINER
이는 CONTAINER라는 ID 또는 이름으로 실행 중인 컨테이너에 연결합니다.

<h1>바인드 마운트 – 바로 가기(Shortcuts)</h1>
간단한 참고 사항: 항상 전체 경로를 복사하여 사용하고 싶지 않은 경우, 다음 바로 가기를 사용할 수 있습니다.<br>

`macOS / Linux: -v $(pwd):/app` <br>

`Windows: -v "%cd%":/app `<br>

모든 분께 적용되는 접근 방식을 보여드리고자 하기 때문에,
강의에서는 이 바로가기를 사용하지 않습니다(매번 둘 사이를 전환하고 싶지는 않음).<br>
하지만 작업 중인 OS에 따라, 타이핑을 절약하기 위해 이 바로 가기를 사용할 수 있습니다.<br>


<h1>Docker 네트워크 드라이버</h1>
Docker Networks는 실제로 네트워크 동작에 영향을 미치는 다양한 종류의 '드라이버'를 지원합니다.

디폴트 드라이버는 'bridge' 드라이버입니다. 이 드라이버는 모듈에 나타난 동작을 제공합니다 (즉, 컨테이너가 동일한 네트워크에 있는 경우, 이름으로 서로를 찾을 수 있음).

드라이버는 네트워크 생성 시 `--driver` 옵션을 추가하여 간단히 설정할 수 있습니다.

`docker network create --driver bridge my-net`
물론 'bridge' 드라이버를 사용하고자 하는 경우, 'bridge'가 디폴트이므로, 전체 옵션을 생략하면 됩니다.

Docker는 아래의 대체 드라이버도 지원하지만 대부분의 경우 'bridge' 드라이버를 사용합니다.


`host`: 스탠드얼론 컨테이너의 경우, 컨테이너와 호스트 시스템 간의 격리가 제거됩니다 (즉, localhost를 네트워크로 공유함).

`overlay`: 여러 Docker 데몬 (즉, 서로 다른 머신에서 실행되는 Docker)이 서로 연결될 수 있습니다. 여러 컨테이너를 연결하는 구식의 / 거의 사용되지 않는 방법인 'Swarm' 모드에서만 작동합니다.

`macvlan`: 컨테이너에 커스텀 MAC 주소를 설정할 수 있습니다. 그러면 이 주소를 해당 컨테이너와 통신하는데 사용할 수 있습니다.

`none`: 모든 네트워킹이 비활성화됩니다.

`써드파티 플러그인`: 모든 종류의 동작과 기능을 추가할 수 있는 타사 플러그인을 설치할 수 있습니다.

언급했듯이 'bridge' 드라이버는 대부분의 시나리오에 가장 적합합니다.

